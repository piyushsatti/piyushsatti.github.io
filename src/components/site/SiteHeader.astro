---
export interface NavItem {
  label: string;
  href: string;
  external?: boolean;
}

export interface Props {
  navItems: NavItem[];
}

const { navItems } = Astro.props;

const palettes = [
  { id: "amber", label: "Amber" },
  { id: "cobalt", label: "Cobalt" },
  { id: "mint", label: "Mint" },
  { id: "rose", label: "Rose" },
];
---

<header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href={navItems[0]?.href ?? "/"}>
        <div class="logo">Terminal&gt;&gt;Pi(π)</div>
      </a>
    </div>
    <div class="header__actions">
      <div class="theme-toggle-group">
        <button
          class="theme-toggle"
          type="button"
          aria-label="Switch to light theme"
        >
          <span
            class="theme-toggle__icon theme-toggle__icon--sun"
            aria-hidden="true">☀</span
          >
          <span
            class="theme-toggle__icon theme-toggle__icon--moon"
            aria-hidden="true">☾</span
          >
        </button>
        <button
          class="palette-trigger"
          type="button"
          aria-haspopup="true"
          aria-expanded="false"
          aria-label="Open palette selector"
        >
          ...
        </button>
        <div
          class="palette-toggle"
          role="group"
          aria-label="Select theme palette"
        >
          {
            palettes.map((palette) => (
              <button
                type="button"
                class="palette-swatch"
                data-palette={palette.id}
                aria-label={`${palette.label} palette`}
                aria-pressed="false"
              />
            ))
          }
        </div>
      </div>
      <ul class="menu menu--mobile">
        <li class="menu__trigger">Menu ▾</li>
        <li>
          <ul class="menu__dropdown">
            {
              navItems
                .filter((item) => item.label !== "Resume")
                .map((item) => (
                  <li>
                    <a
                      href={item.href}
                      target={item.external ? "_blank" : undefined}
                      rel={item.external ? "noopener noreferrer" : undefined}
                    >
                      {item.label}
                    </a>
                  </li>
                ))
            }
            <li class="menu">
              <span class="menu__trigger">Resume ▾</span>
              <ul class="menu__dropdown">
                <li>
                  <a
                    href="/Piyush_Satti_Full_stack_Jan26.pdf"
                    target="_blank"
                    rel="noopener noreferrer">Full Stack Developer</a
                  >
                </li>
                <li>
                  <a
                    href="/Piyush_Satti_Software_engineer_Jan26.pdf"
                    target="_blank"
                    rel="noopener noreferrer">Software Engineering</a
                  >
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </div>
  </div>
  <!-- Menu for desktop -->
  <nav class="navigation-menu">
    <ul class="navigation-menu__inner menu--desktop">
      {
        navItems
          .filter((item) => item.label !== "Resume")
          .map((item) => (
            <li>
              <a
                href={item.href}
                target={item.external ? "_blank" : undefined}
                rel={item.external ? "noopener noreferrer" : undefined}
              >
                {item.label}
              </a>
            </li>
          ))
      }
      <li class="menu">
        <span class="menu__trigger">Resume ▾</span>
        <ul class="menu__dropdown">
          <li>
            <a
              href="/Piyush_Satti_Full_stack_Jan26.pdf"
              target="_blank"
              rel="noopener noreferrer">Full Stack Developer</a
            >
          </li>
          <li>
            <a
              href="/Piyush_Satti_Software_engineer_Jan26.pdf"
              target="_blank"
              rel="noopener noreferrer">Software Engineering</a
            >
          </li>
        </ul>
      </li>
    </ul>
  </nav>
</header>

<div class="chat-overlay" data-chat-overlay hidden>
  <div
    class="chat-panel"
    role="dialog"
    aria-modal="true"
    aria-labelledby="chat-title"
  >
    <div class="chat-header">
      <h2 id="chat-title" class="chat-title">Pi Chat</h2>
      <button
        type="button"
        class="chat-close"
        data-chat-close
        aria-label="Close chat"
      >
        X
      </button>
    </div>
    <div class="chat-body" data-chat-log>
      <div class="chat-message chat-message--bot">
        This is a local demo. Ask me about projects or tech.
      </div>
    </div>
    <form class="chat-footer" data-chat-form>
      <input
        class="chat-input"
        type="text"
        name="message"
        placeholder="Ask about my work..."
        autocomplete="off"
        data-chat-input
      />
      <button class="chat-send" type="submit">Send</button>
    </form>
  </div>
</div>

<script is:inline>
  (() => {
    const scriptPrev = document.currentScript?.previousElementSibling;
    const header =
      scriptPrev instanceof HTMLElement &&
      scriptPrev.classList.contains("header")
        ? scriptPrev
        : document.querySelector(".header");
    if (!(header instanceof HTMLElement)) return;

    const STORAGE_KEY = "terminal-theme-preference";
    const PALETTE_KEY = "terminal-theme-palette";
    const root = document.documentElement;
    const toggle = header.querySelector(".theme-toggle");
    const paletteGroup = header.querySelector(".theme-toggle-group");
    const paletteTrigger = header.querySelector(".palette-trigger");
    const swatches = Array.from(header.querySelectorAll(".palette-swatch"));
    const prefersDark = window.matchMedia?.("(prefers-color-scheme: dark)");

    const isValidPalette = (value) =>
      value === "amber" ||
      value === "cobalt" ||
      value === "mint" ||
      value === "rose";

    const getStoredTheme = () => {
      try {
        const value = localStorage.getItem(STORAGE_KEY);
        return value === "light" || value === "dark" ? value : null;
      } catch (error) {
        console.warn("Unable to read theme from storage", error);
        return null;
      }
    };

    const getStoredPalette = () => {
      try {
        const value = localStorage.getItem(PALETTE_KEY);
        return isValidPalette(value) ? value : null;
      } catch (error) {
        console.warn("Unable to read palette from storage", error);
        return null;
      }
    };

    const setStoredTheme = (value) => {
      try {
        localStorage.setItem(STORAGE_KEY, value);
      } catch (error) {
        console.warn("Unable to persist theme in storage", error);
      }
    };

    const setStoredPalette = (value) => {
      try {
        localStorage.setItem(PALETTE_KEY, value);
      } catch (error) {
        console.warn("Unable to persist palette in storage", error);
      }
    };

    const updatePaletteButtons = (activePalette) => {
      swatches.forEach((button) => {
        if (!(button instanceof HTMLElement)) return;
        const isActive = button.getAttribute("data-palette") === activePalette;
        button.classList.toggle("is-active", isActive);
        button.setAttribute("aria-pressed", String(isActive));
      });
    };

    const applyPalette = (palette, persist = true) => {
      const next = isValidPalette(palette) ? palette : "amber";
      root.setAttribute("data-palette", next);
      updatePaletteButtons(next);
      if (persist) {
        setStoredPalette(next);
      }
      return next;
    };

    const setPaletteOpen = (open) => {
      if (!(paletteGroup instanceof HTMLElement)) return;
      paletteGroup.classList.toggle("is-open", open);
      if (paletteTrigger instanceof HTMLElement) {
        paletteTrigger.setAttribute("aria-expanded", String(open));
      }
    };

    const updateToggleLabel = (theme) => {
      if (!toggle) return;
      const nextTheme = theme === "dark" ? "light" : "dark";
      toggle.setAttribute("aria-label", `Switch to ${nextTheme} theme`);
    };

    const applyTheme = (theme, persist = true) => {
      const normalized = theme === "light" ? "light" : "dark";
      root.setAttribute("data-theme", normalized);
      if (persist) {
        setStoredTheme(normalized);
      }
      updateToggleLabel(normalized);
      return normalized;
    };

    const initialTheme =
      getStoredTheme() ?? (prefersDark?.matches ? "dark" : "light");

    applyTheme(initialTheme, false);
    applyPalette(getStoredPalette() ?? "amber", false);

    toggle?.addEventListener("click", () => {
      const current =
        root.getAttribute("data-theme") === "light" ? "light" : "dark";
      const next = current === "dark" ? "light" : "dark";
      applyTheme(next);
    });

    paletteTrigger?.addEventListener("click", (event) => {
      event.stopPropagation();
      const isOpen =
        paletteGroup instanceof HTMLElement &&
        paletteGroup.classList.contains("is-open");
      setPaletteOpen(!isOpen);
    });

    swatches.forEach((button) => {
      button.addEventListener("click", () => {
        const palette = button.getAttribute("data-palette");
        if (!palette) return;
        applyPalette(palette);
        setPaletteOpen(false);
      });
    });

    document.addEventListener("click", (event) => {
      if (!(paletteGroup instanceof HTMLElement)) return;
      const target = event.target;
      if (target instanceof Node && !paletteGroup.contains(target)) {
        setPaletteOpen(false);
      }
    });

    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        setPaletteOpen(false);
      }
    });

    if (prefersDark) {
      const handleMatchMedia = (event) => {
        if (getStoredTheme()) return;
        applyTheme(event.matches ? "dark" : "light", false);
      };

      if (typeof prefersDark.addEventListener === "function") {
        prefersDark.addEventListener("change", handleMatchMedia);
      } else if (typeof prefersDark.addListener === "function") {
        prefersDark.addListener(handleMatchMedia);
      }
    }

    const menus = Array.from(header.querySelectorAll(".menu")).filter(
      (menu) => menu instanceof HTMLElement
    );

    const closeMenus = () => {
      menus.forEach((menu) => menu.classList.remove("open"));
    };

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof Node)) return;

      // Close all menus if clicking outside header
      if (!header.contains(target)) {
        closeMenus();
        return;
      }

      // Close menus if clicking inside header but not on a trigger or inside a dropdown
      const clickedInsideMenu = menus.some((menu) => {
        const trigger = menu.querySelector(".menu__trigger");
        const dropdown = menu.querySelector(".menu__dropdown");
        return (
          (trigger instanceof HTMLElement && trigger.contains(target)) ||
          (dropdown instanceof HTMLElement && dropdown.contains(target))
        );
      });

      if (!clickedInsideMenu) {
        closeMenus();
      }
    });

    window.addEventListener("resize", closeMenus);

    menus.forEach((menu) => {
      const trigger = menu.querySelector(".menu__trigger");
      const dropdown = menu.querySelector(".menu__dropdown");

      if (
        !(trigger instanceof HTMLElement) ||
        !(dropdown instanceof HTMLElement)
      ) {
        return;
      }

      trigger.addEventListener("click", (event) => {
        event.preventDefault();
        event.stopPropagation();

        const isOpen = menu.classList.toggle("open");
        if (!isOpen) {
          dropdown.removeAttribute("style");
          return;
        }

        const menuRect = dropdown.getBoundingClientRect();
        const headerRect = header.getBoundingClientRect();

        if (menuRect.right > headerRect.right) {
          dropdown.style.left = "auto";
          dropdown.style.right = "0";
        } else {
          dropdown.style.left = "";
          dropdown.style.right = "";
        }
      });

      // Close dropdown when clicking on a link inside it
      dropdown.addEventListener("click", (event) => {
        const target = event.target;
        if (target instanceof HTMLElement && target.tagName === "A") {
          menu.classList.remove("open");
          dropdown.removeAttribute("style");
        }
      });
    });

    const logoLink = header.querySelector(".header__logo a");
    const chatOverlay = document.querySelector("[data-chat-overlay]");
    const chatClose = document.querySelector("[data-chat-close]");
    const chatForm = document.querySelector("[data-chat-form]");
    const chatInput = document.querySelector("[data-chat-input]");
    const chatLog = document.querySelector("[data-chat-log]");
    let chatCloseTimer;

    const openChat = () => {
      if (!(chatOverlay instanceof HTMLElement)) return;
      chatOverlay.hidden = false;
      requestAnimationFrame(() => chatOverlay.classList.add("is-open"));
      if (chatInput instanceof HTMLInputElement) {
        chatInput.focus();
      }
    };

    const closeChat = () => {
      if (!(chatOverlay instanceof HTMLElement)) return;
      chatOverlay.classList.remove("is-open");
      window.clearTimeout(chatCloseTimer);
      chatCloseTimer = window.setTimeout(() => {
        chatOverlay.hidden = true;
      }, 200);
    };

    const appendMessage = (text, role) => {
      if (!(chatLog instanceof HTMLElement)) return;
      const message = document.createElement("div");
      message.className = `chat-message chat-message--${role}`;
      message.textContent = text;
      chatLog.appendChild(message);
      chatLog.scrollTop = chatLog.scrollHeight;
    };

    logoLink?.addEventListener("click", (event) => {
      event.preventDefault();
      openChat();
    });

    chatOverlay?.addEventListener("click", (event) => {
      if (event.target === chatOverlay) {
        closeChat();
      }
    });

    chatClose?.addEventListener("click", closeChat);

    chatForm?.addEventListener("submit", (event) => {
      event.preventDefault();
      if (!(chatInput instanceof HTMLInputElement)) return;
      const value = chatInput.value.trim();
      if (!value) return;
      appendMessage(value, "user");
      chatInput.value = "";
      window.setTimeout(() => {
        appendMessage(
          "Thanks for the note. This demo is UI-only for now.",
          "bot"
        );
      }, 300);
    });

    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        closeChat();
      }
    });
  })();
</script>
