---
export interface NavItem {
  label: string;
  href: string;
  external?: boolean;
}

export interface Props {
  navItems: NavItem[];
}

const { navItems } = Astro.props;

const palettes = [
  { id: "amber", label: "Amber" },
  { id: "cobalt", label: "Cobalt" },
  { id: "mint", label: "Mint" },
  { id: "rose", label: "Rose" },
];
---

<header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href={navItems[0]?.href ?? "/"} title="Click here for piChat">
        <div class="logo logo--shine">Terminal&gt;&gt;Pi(π)</div>
      </a>
    </div>
    <div class="header__actions">
      <div class="theme-toggle-group">
        <button
          class="theme-toggle"
          type="button"
          aria-label="Switch to light theme"
        >
          <span
            class="theme-toggle__icon theme-toggle__icon--sun"
            aria-hidden="true">☀</span
          >
          <span
            class="theme-toggle__icon theme-toggle__icon--moon"
            aria-hidden="true">☾</span
          >
        </button>
        <button
          class="palette-trigger"
          type="button"
          aria-haspopup="true"
          aria-expanded="false"
          aria-label="Open palette selector"
        >
          ...
        </button>
        <div
          class="palette-toggle"
          role="group"
          aria-label="Select theme palette"
        >
          {
            palettes.map((palette) => (
              <button
                type="button"
                class="palette-swatch"
                data-palette={palette.id}
                aria-label={`${palette.label} palette`}
                aria-pressed="false"
              />
            ))
          }
        </div>
      </div>
      <ul class="menu menu--mobile">
        <li class="menu__trigger">Menu ▾</li>
        <li>
          <ul class="menu__dropdown">
            {
              navItems
                .filter((item) => item.label !== "Resume")
                .map((item) => (
                  <li>
                    <a
                      href={item.href}
                      target={item.external ? "_blank" : undefined}
                      rel={item.external ? "noopener noreferrer" : undefined}
                    >
                      {item.label}
                    </a>
                  </li>
                ))
            }
            <li class="menu">
              <span class="menu__trigger">Resume ▾</span>
              <ul class="menu__dropdown">
                <li>
                  <a
                    href="/Piyush_Satti_Full_stack_Jan26.pdf"
                    target="_blank"
                    rel="noopener noreferrer">Full Stack Developer</a
                  >
                </li>
                <li>
                  <a
                    href="/Piyush_Satti_Software_engineer_Jan26.pdf"
                    target="_blank"
                    rel="noopener noreferrer">Software Engineering</a
                  >
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </div>
  </div>
  <!-- Menu for desktop -->
  <nav class="navigation-menu">
    <ul class="navigation-menu__inner menu--desktop">
      {
        navItems
          .filter((item) => item.label !== "Resume")
          .map((item) => (
            <li>
              <a
                href={item.href}
                target={item.external ? "_blank" : undefined}
                rel={item.external ? "noopener noreferrer" : undefined}
              >
                {item.label}
              </a>
            </li>
          ))
      }
      <li class="menu">
        <span class="menu__trigger">Resume ▾</span>
        <ul class="menu__dropdown">
          <li>
            <a
              href="/Piyush_Satti_Full_stack_Jan26.pdf"
              target="_blank"
              rel="noopener noreferrer">Full Stack Developer</a
            >
          </li>
          <li>
            <a
              href="/Piyush_Satti_Software_engineer_Jan26.pdf"
              target="_blank"
              rel="noopener noreferrer">Software Engineering</a
            >
          </li>
        </ul>
      </li>
    </ul>
  </nav>
</header>

<div class="chat-embed" data-chat-overlay hidden>
  <div class="chat-panel" role="region" aria-labelledby="chat-title">
    <div class="chat-header">
      <h2 id="chat-title" class="chat-title">Pi Chat</h2>
      <button
        type="button"
        class="chat-close"
        data-chat-close
        aria-label="Close chat"
      >
        ✕
      </button>
    </div>
    <div class="chat-body" data-chat-log>
      <div class="chat-message chat-message--bot">
        This is a local demo. Ask me about projects or tech.
      </div>
    </div>
    <form class="chat-footer" data-chat-form>
      <input
        class="chat-input"
        type="text"
        name="message"
        placeholder="Ask about my work..."
        autocomplete="off"
        data-chat-input
      />
      <button class="chat-send" type="submit">Send</button>
    </form>
  </div>
</div>

<script is:inline>
  (() => {
    const scriptPrev = document.currentScript?.previousElementSibling;
    const header =
      scriptPrev instanceof HTMLElement &&
      scriptPrev.classList.contains("header")
        ? scriptPrev
        : document.querySelector(".header");
    if (!(header instanceof HTMLElement)) return;

    const STORAGE_KEY = "terminal-theme-preference";
    const PALETTE_KEY = "terminal-theme-palette";
    const CHAT_SESSION_KEY = "chat-session-token";
    const CHAT_HISTORY_KEY = "chat-history";
    const CHAT_API_URL = "https://pichatwithme.vercel.app";
    const MAX_CHAT_HISTORY = 50;
    const root = document.documentElement;
    const toggle = header.querySelector(".theme-toggle");
    const paletteGroup = header.querySelector(".theme-toggle-group");
    const paletteTrigger = header.querySelector(".palette-trigger");
    const swatches = Array.from(header.querySelectorAll(".palette-swatch"));
    const prefersDark = window.matchMedia?.("(prefers-color-scheme: dark)");

    const isValidPalette = (value) =>
      value === "amber" ||
      value === "cobalt" ||
      value === "mint" ||
      value === "rose";

    const getStoredTheme = () => {
      try {
        const value = localStorage.getItem(STORAGE_KEY);
        return value === "light" || value === "dark" ? value : null;
      } catch (error) {
        console.warn("Unable to read theme from storage", error);
        return null;
      }
    };

    const getStoredPalette = () => {
      try {
        const value = localStorage.getItem(PALETTE_KEY);
        return isValidPalette(value) ? value : null;
      } catch (error) {
        console.warn("Unable to read palette from storage", error);
        return null;
      }
    };

    const setStoredTheme = (value) => {
      try {
        localStorage.setItem(STORAGE_KEY, value);
      } catch (error) {
        console.warn("Unable to persist theme in storage", error);
      }
    };

    const setStoredPalette = (value) => {
      try {
        localStorage.setItem(PALETTE_KEY, value);
      } catch (error) {
        console.warn("Unable to persist palette in storage", error);
      }
    };

    const updatePaletteButtons = (activePalette) => {
      swatches.forEach((button) => {
        if (!(button instanceof HTMLElement)) return;
        const isActive = button.getAttribute("data-palette") === activePalette;
        button.classList.toggle("is-active", isActive);
        button.setAttribute("aria-pressed", String(isActive));
      });
    };

    const applyPalette = (palette, persist = true) => {
      const next = isValidPalette(palette) ? palette : "amber";
      root.setAttribute("data-palette", next);
      updatePaletteButtons(next);
      if (persist) {
        setStoredPalette(next);
      }
      return next;
    };

    const setPaletteOpen = (open) => {
      if (!(paletteGroup instanceof HTMLElement)) return;
      paletteGroup.classList.toggle("is-open", open);
      if (paletteTrigger instanceof HTMLElement) {
        paletteTrigger.setAttribute("aria-expanded", String(open));
      }
    };

    const updateToggleLabel = (theme) => {
      if (!toggle) return;
      const nextTheme = theme === "dark" ? "light" : "dark";
      toggle.setAttribute("aria-label", `Switch to ${nextTheme} theme`);
    };

    const applyTheme = (theme, persist = true) => {
      const normalized = theme === "light" ? "light" : "dark";
      root.setAttribute("data-theme", normalized);
      if (persist) {
        setStoredTheme(normalized);
      }
      updateToggleLabel(normalized);
      return normalized;
    };

    const initialTheme =
      getStoredTheme() ?? (prefersDark?.matches ? "dark" : "light");

    applyTheme(initialTheme, false);
    applyPalette(getStoredPalette() ?? "amber", false);

    toggle?.addEventListener("click", () => {
      const current =
        root.getAttribute("data-theme") === "light" ? "light" : "dark";
      const next = current === "dark" ? "light" : "dark";
      applyTheme(next);
    });

    paletteTrigger?.addEventListener("click", (event) => {
      event.stopPropagation();
      const isOpen =
        paletteGroup instanceof HTMLElement &&
        paletteGroup.classList.contains("is-open");
      setPaletteOpen(!isOpen);
    });

    swatches.forEach((button) => {
      button.addEventListener("click", () => {
        const palette = button.getAttribute("data-palette");
        if (!palette) return;
        applyPalette(palette);
        setPaletteOpen(false);
      });
    });

    document.addEventListener("click", (event) => {
      if (!(paletteGroup instanceof HTMLElement)) return;
      const target = event.target;
      if (target instanceof Node && !paletteGroup.contains(target)) {
        setPaletteOpen(false);
      }
    });

    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        setPaletteOpen(false);
      }
    });

    if (prefersDark) {
      const handleMatchMedia = (event) => {
        if (getStoredTheme()) return;
        applyTheme(event.matches ? "dark" : "light", false);
      };

      if (typeof prefersDark.addEventListener === "function") {
        prefersDark.addEventListener("change", handleMatchMedia);
      } else if (typeof prefersDark.addListener === "function") {
        prefersDark.addListener(handleMatchMedia);
      }
    }

    const menus = Array.from(header.querySelectorAll(".menu")).filter(
      (menu) => menu instanceof HTMLElement
    );

    const closeMenus = () => {
      menus.forEach((menu) => menu.classList.remove("open"));
    };

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof Node)) return;

      // Close all menus if clicking outside header
      if (!header.contains(target)) {
        closeMenus();
        return;
      }

      // Close menus if clicking inside header but not on a trigger or inside a dropdown
      const clickedInsideMenu = menus.some((menu) => {
        const trigger = menu.querySelector(".menu__trigger");
        const dropdown = menu.querySelector(".menu__dropdown");
        return (
          (trigger instanceof HTMLElement && trigger.contains(target)) ||
          (dropdown instanceof HTMLElement && dropdown.contains(target))
        );
      });

      if (!clickedInsideMenu) {
        closeMenus();
      }
    });

    window.addEventListener("resize", closeMenus);

    menus.forEach((menu) => {
      const trigger = menu.querySelector(".menu__trigger");
      const dropdown = menu.querySelector(".menu__dropdown");

      if (
        !(trigger instanceof HTMLElement) ||
        !(dropdown instanceof HTMLElement)
      ) {
        return;
      }

      trigger.addEventListener("click", (event) => {
        event.preventDefault();
        event.stopPropagation();

        const isOpen = menu.classList.toggle("open");
        if (!isOpen) {
          dropdown.removeAttribute("style");
          return;
        }

        const menuRect = dropdown.getBoundingClientRect();
        const headerRect = header.getBoundingClientRect();

        if (menuRect.right > headerRect.right) {
          dropdown.style.left = "auto";
          dropdown.style.right = "0";
        } else {
          dropdown.style.left = "";
          dropdown.style.right = "";
        }
      });

      // Close dropdown when clicking on a link inside it
      dropdown.addEventListener("click", (event) => {
        const target = event.target;
        if (target instanceof HTMLElement && target.tagName === "A") {
          menu.classList.remove("open");
          dropdown.removeAttribute("style");
        }
      });
    });

    const logoLink = header.querySelector(".header__logo a");
    const chatOverlay = document.querySelector("[data-chat-overlay]");
    const chatClose = document.querySelector("[data-chat-close]");
    const chatForm = document.querySelector("[data-chat-form]");
    const chatInput = document.querySelector("[data-chat-input]");
    const chatLog = document.querySelector("[data-chat-log]");
    let chatCloseTimer;

    const openChat = () => {
      if (!(chatOverlay instanceof HTMLElement)) return;
      chatOverlay.hidden = false;
      // Force reflow for animation
      chatOverlay.offsetHeight;
      requestAnimationFrame(() => chatOverlay.classList.add("is-open"));
      if (chatInput instanceof HTMLInputElement) {
        chatInput.focus();
      }
    };

    const closeChat = () => {
      if (!(chatOverlay instanceof HTMLElement)) return;
      chatOverlay.classList.remove("is-open");
      window.clearTimeout(chatCloseTimer);
      chatCloseTimer = window.setTimeout(() => {
        chatOverlay.hidden = true;
      }, 300);
    };

    // Session management
    let sessionToken = null;
    let isRateLimited = false;
    let thinkingElement = null;

    const getStoredSession = () => {
      try {
        return localStorage.getItem(CHAT_SESSION_KEY);
      } catch (e) {
        console.warn("Unable to read session from storage", e);
        return null;
      }
    };

    const setStoredSession = (token) => {
      try {
        localStorage.setItem(CHAT_SESSION_KEY, token);
      } catch (e) {
        console.warn("Unable to persist session in storage", e);
      }
    };

    const createSession = async () => {
      try {
        const res = await fetch(`${CHAT_API_URL}/api/session`, {
          method: "POST",
        });
        if (!res.ok) throw new Error("Failed to create session");
        const data = await res.json();
        sessionToken = data.sessionToken;
        setStoredSession(sessionToken);
        return sessionToken;
      } catch (e) {
        console.error("Session creation failed", e);
        return null;
      }
    };

    const getOrCreateSession = async () => {
      if (sessionToken) return sessionToken;
      sessionToken = getStoredSession();
      if (sessionToken) return sessionToken;
      return await createSession();
    };

    // Chat history persistence
    const getChatHistory = () => {
      try {
        const stored = localStorage.getItem(CHAT_HISTORY_KEY);
        return stored ? JSON.parse(stored) : [];
      } catch (e) {
        console.warn("Unable to read chat history", e);
        return [];
      }
    };

    const saveChatHistory = (messages) => {
      try {
        const trimmed = messages.slice(-MAX_CHAT_HISTORY);
        localStorage.setItem(CHAT_HISTORY_KEY, JSON.stringify(trimmed));
      } catch (e) {
        console.warn("Unable to persist chat history", e);
      }
    };

    const loadChatHistory = () => {
      if (!(chatLog instanceof HTMLElement)) return;
      const history = getChatHistory();
      if (history.length === 0) return;

      // Clear default welcome message if we have history
      chatLog.innerHTML = "";
      history.forEach(({ text, role }) => {
        const message = document.createElement("div");
        message.className = `chat-message chat-message--${role}`;
        message.textContent = text;
        chatLog.appendChild(message);
      });
      chatLog.scrollTop = chatLog.scrollHeight;
    };

    // Append message and persist
    const appendMessage = (text, role, persist = true) => {
      if (!(chatLog instanceof HTMLElement)) return;
      const message = document.createElement("div");
      message.className = `chat-message chat-message--${role}`;
      message.textContent = text;
      chatLog.appendChild(message);
      chatLog.scrollTop = chatLog.scrollHeight;

      if (persist) {
        const history = getChatHistory();
        history.push({ text, role });
        saveChatHistory(history);
      }
    };

    // Thinking indicator
    const showThinking = () => {
      if (!(chatLog instanceof HTMLElement)) return;
      thinkingElement = document.createElement("div");
      thinkingElement.className =
        "chat-message chat-message--bot chat-message--thinking";
      thinkingElement.innerHTML =
        '<span class="thinking-dots">Thinking<span>.</span><span>.</span><span>.</span></span>';
      chatLog.appendChild(thinkingElement);
      chatLog.scrollTop = chatLog.scrollHeight;
    };

    const hideThinking = () => {
      if (thinkingElement && thinkingElement.parentNode) {
        thinkingElement.parentNode.removeChild(thinkingElement);
        thinkingElement = null;
      }
    };

    // Rate limit handling
    const handleRateLimit = (retryAfter, message) => {
      isRateLimited = true;
      if (chatInput instanceof HTMLInputElement) {
        chatInput.disabled = true;
        chatInput.placeholder =
          message || `Rate limited. Wait ${retryAfter}s...`;
      }

      let remaining = retryAfter;
      const countdown = setInterval(() => {
        remaining--;
        if (chatInput instanceof HTMLInputElement) {
          chatInput.placeholder = `Please wait ${remaining}s...`;
        }
        if (remaining <= 0) {
          clearInterval(countdown);
          isRateLimited = false;
          if (chatInput instanceof HTMLInputElement) {
            chatInput.disabled = false;
            chatInput.placeholder = "Ask about my work...";
            chatInput.focus();
          }
        }
      }, 1000);
    };

    // Send message to API
    const sendMessage = async (question) => {
      const token = await getOrCreateSession();
      if (!token) {
        return { error: "Unable to establish session. Please try again." };
      }

      try {
        const res = await fetch(`${CHAT_API_URL}/api/chat`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ sessionToken: token, question }),
        });

        if (res.status === 429) {
          const { message, retryAfter } = await res.json();
          return { rateLimited: true, message, retryAfter };
        }

        if (res.status === 404) {
          // Session expired - silently create new one and retry
          sessionToken = null;
          localStorage.removeItem(CHAT_SESSION_KEY);
          const newToken = await createSession();
          if (!newToken) {
            return { error: "Session expired. Please try again." };
          }
          // Retry with new session
          const retryRes = await fetch(`${CHAT_API_URL}/api/chat`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ sessionToken: newToken, question }),
          });
          if (!retryRes.ok) {
            return { error: "Something went wrong. Please try again." };
          }
          const retryData = await retryRes.json();
          return { answer: retryData.answer };
        }

        if (!res.ok) {
          return { error: "Something went wrong. Please try again." };
        }

        const data = await res.json();
        return { answer: data.answer };
      } catch (e) {
        console.error("Chat API error", e);
        return { error: "Network error. Please check your connection." };
      }
    };

    // Load history on page load
    loadChatHistory();

    logoLink?.addEventListener("click", (event) => {
      event.preventDefault();
      // Toggle chat open/close
      if (
        chatOverlay instanceof HTMLElement &&
        chatOverlay.classList.contains("is-open")
      ) {
        closeChat();
      } else {
        openChat();
      }
    });

    chatClose?.addEventListener("click", closeChat);

    chatForm?.addEventListener("submit", async (event) => {
      event.preventDefault();
      if (!(chatInput instanceof HTMLInputElement)) return;
      if (isRateLimited) return;

      const value = chatInput.value.trim();
      if (!value) return;

      appendMessage(value, "user");
      chatInput.value = "";
      chatInput.disabled = true;

      showThinking();

      const result = await sendMessage(value);

      hideThinking();
      chatInput.disabled = false;

      if (result.rateLimited) {
        appendMessage(
          result.message || "Too many requests. Please slow down.",
          "bot"
        );
        handleRateLimit(result.retryAfter || 60, result.message);
      } else if (result.error) {
        appendMessage(result.error, "bot");
      } else if (result.answer) {
        appendMessage(result.answer, "bot");
      }

      if (!isRateLimited) {
        chatInput.focus();
      }
    });

    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        closeChat();
      }
    });
  })();
</script>
